<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Receipt OCR → Excel (Florista Sekar)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Arial;background:#fbfaf9;color:#222;margin:0;padding:20px}
    h1{color:#c94a8a;text-align:center}
    .wrap{max-width:1100px;margin:18px auto;padding:20px;background:#fff;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.06)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}
    input[type=file]{padding:8px}
    button{background:#25d366;color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
    button.secondary{background:#3b82f6}
    .progress{margin:8px 0;color:#666}
    pre{background:#f5f5f7;padding:10px;border-radius:6px;overflow:auto;max-height:200px}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px;border:1px solid #eee;text-align:left;font-size:14px}
    .small{font-size:13px;color:#666}
    .center{text-align:center}
    .tag{background:#f0f0f3;padding:3px 6px;border-radius:6px;margin-right:6px}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    .note{font-size:13px;color:#666;margin-top:8px}
    @media(max-width:700px){.controls{flex-direction:column}table{font-size:12px}}
  </style>

  <!-- Tesseract.js and SheetJS from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>Florista Sekar — Receipt OCR → Excel</h1>

    <div class="controls">
      <input id="files" type="file" accept="image/*" multiple>
      <button id="processBtn" class="secondary">Process Selected</button>
      <button id="downloadBtn">Download Excel</button>
      <button id="clearBtn">Clear All</button>
    </div>

    <div class="progress" id="status">Select one or more receipt images (JPG/PNG), then click <strong>Process Selected</strong>.</div>

    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <div style="flex:1;min-width:280px">
        <h3>Raw OCR output</h3>
        <pre id="rawText">—</pre>
      </div>

      <div style="flex:1;min-width:300px">
        <h3>Parsed rows</h3>
        <div class="note">You can review results below. Edit cells in the table if OCR made mistakes, then click <strong>Download Excel</strong>.</div>
        <div id="tableWrap"></div>
      </div>
    </div>
  </div>

<script>
/*
  OCR + Parse + Export demo.
  Uses Tesseract.js (in-browser OCR) and SheetJS (xlsx export).
  Parsing is heuristic: it handles date lines like 4/9 or 15/09 and inherits previous date when date is blank.
*/

const filesEl = document.getElementById('files');
const processBtn = document.getElementById('processBtn');
const rawTextEl = document.getElementById('rawText');
const tableWrap = document.getElementById('tableWrap');
const statusEl = document.getElementById('status');
const downloadBtn = document.getElementById('downloadBtn');
const clearBtn = document.getElementById('clearBtn');

let parsedRows = []; // final array of objects

// helper: normalize amount string into number string (e.g. '250.000' -> '250000' or '250000.50')
function normalizeAmount(s) {
  if(!s) return '';
  // remove spaces, currency symbols
  s = s.replace(/[^\d.,-]/g, '').trim();
  // if contains both '.' and ',', decide which is thousand sep: common: 250.000 or 250,000
  if (s.indexOf('.')>-1 && s.indexOf(',')>-1) {
    // if . appears before , then maybe European? fallback: remove dots as thousands
    if (s.indexOf('.') < s.indexOf(',')) {
      s = s.replace(/\./g,'').replace(',', '.');
    } else {
      s = s.replace(/,/g,'').replace('.', '.');
    }
  } else {
    // only dots or only commas
    // treat '.' as thousand separator if groups of 3 digits, else decimal
    if (s.indexOf('.') > -1 && /\.\d{3}$/.test(s)) {
      s = s.replace(/\./g,'');
    } else if (s.indexOf(',') > -1 && /,\d{3}$/.test(s)) {
      s = s.replace(/,/g,'');
    } else {
      // replace comma with dot for decimals
      s = s.replace(/,/g,'.');
    }
  }
  return s;
}

// parse OCR text into structured rows
function parseReceiptText(text) {
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l !== '');
  let results = [];
  let currentDate = '';
  // regexes
  const dateRe = /^(\d{1,2}\s*[\/\-]\s*\d{1,2})(?:\s*\/\s*\d{2,4})?/; // matches 4/9 or 15/09 etc.
  const amountRe = /(\d{1,3}(?:[.,]\d{3})+(?:[.,]\d+)?|\d+(?:[.,]\d+)?)/g; // matches 250.000, 65.000, 1000, 1000.50
  const typeRe = /\(([^)]+)\)/; // (cash), (tf), etc.

  for (let i=0;i<lines.length;i++) {
    const raw = lines[i];

    // try to detect a table row: some have date at start
    let rowDate = null;
    const dateMatch = raw.match(dateRe);
    if (dateMatch) {
      rowDate = dateMatch[1].replace(/\s+/g,''); // e.g. "4/9" or "15/09"
      // normalize to dd/mm/yyyy-ish (we only have day/month) -> keep as dd/mm
      // if month missing zero-pad
      const parts = rowDate.split(/[\/\-]/).map(s=>s.trim());
      let d = parts[0].padStart(2,'0');
      let m = parts[1].padStart(2,'0');
      currentDate = `${d}/${m}`; // store as dd/mm
    }

    // if not date line but maybe description or continuation, we still parse
    // find amounts
    const amounts = [];
    let m;
    while ((m = amountRe.exec(raw)) !== null) {
      amounts.push(m[1]);
    }

    // find type e.g. (cash) or (Tf)
    const typeMatch = raw.match(typeRe);
    const payType = typeMatch ? typeMatch[1].replace(/[.:]/g,'').trim() : '';

    // build description: remove date, amounts, parentheses and separators
    let desc = raw;
    if (dateMatch) desc = desc.replace(dateMatch[0],'');
    desc = desc.replace(typeRe,'');
    // remove found amount tokens from the description to leave only text
    if (amounts.length) {
      amounts.forEach(a => { desc = desc.replace(a,''); });
    }
    // remove extra separators
    desc = desc.replace(/[-–:\|]+/g,' ').replace(/\s{2,}/g,' ').trim();

    // determine debit/credit
    let debit = '', credit = '';
    if (amounts.length === 1) {
      // likely debit column (your sample shows debit amounts)
      debit = normalizeAmount(amounts[0]);
    } else if (amounts.length >= 2) {
      // pick first as debit, last as credit heuristic
      debit = normalizeAmount(amounts[0]);
      credit = normalizeAmount(amounts[amounts.length-1]);
    }

    // if desc ends up empty and no amounts, skip
    if (!desc && !debit && !credit) continue;

    results.push({
      Date: currentDate || '',
      Description: desc,
      Debit: debit,
      Credit: credit,
      Type: payType,
      Raw: raw
    });
  }

  return results;
}

async function ocrFile(file, onProgress) {
  const worker = Tesseract.createWorker({
    logger: m => {
      if (m.status === 'recognizing text' && onProgress) onProgress(Math.round(m.progress*100));
    }
  });
  await worker.load();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  const { data: { text } } = await worker.recognize(file);
  await worker.terminate();
  return text;
}

// process selected files
processBtn.addEventListener('click', async () => {
  const files = filesEl.files;
  if (!files || files.length === 0) { alert('Select at least one image file'); return; }
  statusEl.textContent = `Processing ${files.length} file(s)... this may take a few moments (OCR runs locally).`;
  rawTextEl.textContent = '';
  parsedRows = [];

  for (let i=0;i<files.length;i++) {
    const file = files[i];
    statusEl.textContent = `OCR: processing ${file.name} (${i+1}/${files.length})...`;
    try {
      const text = await ocrFile(file, p => statusEl.textContent = `OCR ${file.name}: ${p}%`);
      rawTextEl.textContent += `--- ${file.name} ---\n` + text + '\n\n';
      // parse
      const parsed = parseReceiptText(text);
      // attach source file name
      parsed.forEach(r => r.SourceFile = file.name);
      parsedRows = parsedRows.concat(parsed);
      statusEl.textContent = `Processed ${file.name} — parsed ${parsed.length} rows`;
    } catch (err) {
      console.error(err);
      statusEl.textContent = `Error OCR ${file.name}: ${err.message||err}`;
    }
  }

  statusEl.textContent = `All files processed — total rows parsed: ${parsedRows.length}`;
  renderTable();
});

// render editable HTML table
function renderTable() {
  if (parsedRows.length === 0) {
    tableWrap.innerHTML = '<div class="small">No parsed rows yet.</div>';
    return;
  }
  let html = '<table><thead><tr><th>#</th><th>Date</th><th>Description</th><th>Debit</th><th>Credit</th><th>Type</th><th>Source</th></tr></thead><tbody>';
  parsedRows.forEach((r, idx) => {
    html += `<tr>
      <td class="center">${idx+1}</td>
      <td contenteditable="true">${r.Date||''}</td>
      <td contenteditable="true">${escapeHtml(r.Description||'')}</td>
      <td contenteditable="true">${r.Debit||''}</td>
      <td contenteditable="true">${r.Credit||''}</td>
      <td contenteditable="true">${r.Type||''}</td>
      <td>${r.SourceFile||''}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  html += '<div class="note">Tip: you can edit cells directly. After edits, click <strong>Download Excel</strong>.</div>';
  tableWrap.innerHTML = html;
}

// helper to escape HTML in cell initial values
function escapeHtml(s){
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;');
}

// download current table to Excel
downloadBtn.addEventListener('click', () => {
  // read back table values (user may have edited)
  const table = tableWrap.querySelector('table');
  if (!table) { alert('No table to export'); return; }
  const rows = [];
  const trs = table.querySelectorAll('tbody tr');
  trs.forEach(tr => {
    const cells = tr.querySelectorAll('td');
    rows.push({
      Date: cells[1].innerText.trim(),
      Description: cells[2].innerText.trim(),
      Debit: cells[3].innerText.trim(),
      Credit: cells[4].innerText.trim(),
      Type: cells[5].innerText.trim(),
      SourceFile: cells[6].innerText.trim()
    });
  });

  // convert Debit/Credit strings to numbers if possible
  const cleaned = rows.map(r => ({
    Date: r.Date,
    Description: r.Description,
    Debit: r.Debit ? Number(normalizeAmount(r.Debit)) : '',
    Credit: r.Credit ? Number(normalizeAmount(r.Credit)) : '',
    Type: r.Type,
    SourceFile: r.SourceFile
  }));

  const ws = XLSX.utils.json_to_sheet(cleaned, {header:["Date","Description","Debit","Credit","Type","SourceFile"]});
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Transactions");
  const fname = `transactions_${(new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-')}.xlsx`;
  XLSX.writeFile(wb, fname);
});

// clear
clearBtn.addEventListener('click', () => {
  parsedRows = [];
  rawTextEl.textContent = '—';
  tableWrap.innerHTML = '';
  filesEl.value = '';
  statusEl.textContent = 'Cleared.';
});

</script>
</body>
</html>
